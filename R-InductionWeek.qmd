---
author: Dr Wei Miao
date: "`r (lubridate::ymd('20230927'))`"
date-format: long
institute: UCL School of Management
toc: true
toc-depth: 2
format:
  html: 
    number-sections: true
    df-print: paged
    page-layout: full
    toc-depth: 2
    code-line-numbers: false
    code-copy: hover
    title: "R Basics"
  pdf: 
    number-sections: true
    number-depth: 2
    fontsize: 10pt
    colorlinks: true
    code-line-numbers: true
    title: "R Basics"
knitr:
  opts_chunk:
    echo: true
    warning: true
    message: true
    error: true
execute: 
  freeze: auto
  cache: true
editor_options: 
  chunk_output_type: inline
---

# Hello R

## Bilingual arrangements at MSc BA

-   Primary language is Python

    -   Programming (MSIN00143), Business Strategy (MSIN0093), Machine Learning electives

-   Secondary language is R

    -   Marketing Analytics (MSIN0094), Operations Analytics (MSIN0095), Statistical Foundations (MSIN0096)

## A brief history of R

-   R project was initiated by **R**obert Gentleman and **R**oss Ihaka (Univ of Auckland) in 1991; both are statisticians, who later made the language **open-source**.

-   Since 1997, R has been developed by the R Core Team on CRAN.

-   As of January 2022, it has almost 20k contributed packages. As of March 2022, R ranks 11th in the TIOBE index[^1].

[^1]: A measure of programming language popularity

## Why learn R?

-   Super powerful data analytics and visualizations, including[^2]

    -   Data wrangling (`dplyr`) and data visualization (`ggplot`)

    -   Econometrics (major advantage of R over Python)

    -   Predictive analytics such as machine learning

-   Write beautiful reports/dissertations/presentations using `Quarto`

    -   Write your MSc dissertation (highly recommended)

    -   Effortlessly build websites. I built and maintain my [personal website](http://miaowei.netlify.app) and the marketing course website all in R.

[^2]: There are many R-exclusive packages, such as the state-of-the-art causal machine learning library `grf` , which we will learn in the final week.

## One-One comparison with Python

+--------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------+
|                                            | R                                                                                                                                        | Python                                                                                                        |
+============================================+==========================================================================================================================================+===============================================================================================================+
| Language purpose                           | R is a **statistical language** specialized in the **data analytics and visualization**.                                                 | Python is a **general-purpose language** that is used for the deployment and development of various projects. |
|                                            |                                                                                                                                          |                                                                                                               |
|                                            | Best for data science, may not be robust for production environment.                                                                     | Best for production environment.                                                                              |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------+
| Data analytics                             | R is better at **statistical models** and **econometrics**.                                                                              | Python is better at **machine learning** due to support from PyTorch and TensorFlow.                          |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------+
| IDEs (Intergrated Development Environment) | RStudio                                                                                                                                  | Many options such as Jupyter Notebook, Spyder, Pycharm, etc.                                                  |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------+
| Targeted users                             | Primary users of R include **data** **scientists** and **researchers** in academia, who heavily rely on data analyses and visualization. | Primary users of python include **developers and programmers.**                                               |
+--------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------+

: R versus Python

## A first look at the RStudio Interface

R is the **programming language**, and we need a "place" to write codes. This place is called an **Integrated development environment (IDE)**.

RStudio is THE best R IDE to date. And it's interface consists of the following major components:

-   ***script***: (top left) where you do the coding

-   ***console***: (bottom left) where you can run commands interactively with R and see code outputs

-   ***environment***: (top right) a list of named objects that we have generated

-   ***history***: (top right) the list of past commands that we have used

-   ***help***: (bottom right) user manuals of functions available in R

-   ***package***: (bottom right) a collection of ready-to-use packages written by others

![](images/r_Rstudio.png)

## Where to write R codes (I): Console

-   You can write codes *interactively* in the R console. See an example: Type the following code into your console and see what happens.

    ```{r}
    print('Hello World')
    ```

-   Used **for simple exploratory, unstructured tasks**, where you don't need to keep a record of codes.

    -   e.g., summary statistics; check variable values, etc.

## Where to write R codes (II): `.R` script

-   `R script` is a text-readable file ending with `.R` suffix. See an example.

    -   codes can be run line-by-line or *sourced* altogether

        ::: callout-important
        All texts in the script will be treated as R codes
        :::

-   Often used for project development and deployment, where you don't need to communicate results to others

## Where to write R codes (III): `.qmd` script

-   `Quarto`[^3] files have a `.qmd` suffix. You can think of Quarto as **Microsoft Word that can run R codes**.

-   Quarto can create dynamic contents with Python and R, conveniently combining data analytics work with beautiful reporting.

    -   If you are familiar with Python, Quarto can be thought of as the R equivalent of Jupyter Notebook
    -   We will be mainly using Quarto in the marketing analytics module.
    -   You can also use Quarto to do your assignments for other modules, write your dissertation, and build your own blogging websites.

-   Now, let's create a new quarto file together!

[^3]: Why the name Quarto? "We wanted to use a name that had meaning in the history of publishing and landed on Quarto, which is the format of a book or pamphlet produced from full sheets printed with eight pages of text, four to a side, then folded twice to produce four leaves. The earliest known European printed book is a Quarto, the [Sibyllenbuch](https://en.wikipedia.org/wiki/Sibyllenbuch_fragment), believed to have been printed by [Johannes Gutenberg](https://en.wikipedia.org/wiki/Johannes_Gutenberg) in 1452--53."

# Introduction to Quarto

## YAML header

-   You can think of YAML header as a MS Word template, which determines how your final report looks like (font, font size, color, margins, etc.).

-   The YAML header is typically at the beginning of a document, separated from the main text by three dashes (`---`). YAML will not appear in the final report.

-   To make life easier, I will set `YAML` headers for all .`qmd` files for you in Marketing Analytics module.

## Authoring with normal texts

RStudio provides two ways to edit a quarto file (1) **visual mode** and (2) **source mode**.

-   RStudio's [visual editor](https://quarto.org/docs/visual-editor/) offers an [WYSIWYM](https://en.wikipedia.org/wiki/WYSIWYM) (Microsoft Word like) authoring experience for markdown

    -   recommended and easier to learn; we will be using this mode in class
    -   check the rich formatting tools we can use for authoring a report

-   In the source mode, you can edit the file using markdown syntax

    -   optional; recommended for advanced users once you're familiar with the markdown syntax

![Visual Mode versus Source Mode](images/quarto%20mode.png){fig-align="center"}

::: callout-note
### Exercise

Create a new quarto file from RStudio with the following level-1 and level-2 headers

-   Basics of R

-   Basics of Quarto
:::

## Coding with code blocks

-   In qmd files, we write R codes in so-called **code chunks** identified with `{r}`.

-   You can run each code chunk interactively by clicking the green solid triangle. RStudio executes the codes in the code chunk and displays the results.

-   To insert a code chunk, click `Insert` -\>`Code Chunk` -\> `R`.

-   See an example and try on your computer!

::: callout-warning
## Caveat

Leave the first line as {r} only, do not write anything else on the first line!
:::

```{r}
print('R is the Best Language! Much better than Python! And please dont tell David I said this!')
```

::: callout-note
### Exercise

Insert the above R code block in your quarto file under any section.
:::

## Rendering a report

At the end, when the Quarto document (including codes and main texts) are ready, use the **`Render`** button in the RStudio IDE to render the file.

The rendered report will be in the same folder with your qmd file.

![](images/render_icon.png)

::: callout-note
### Exercise

Render your quarto file into a document and see how it looks like.
:::

## More learning resources for Quarto

-   The available YAML fields vary based on document format

    -   [Here](https://quarto.org/docs/reference/formats/pdf.html) for YAML fields for PDF documents
    -   [Here](https://quarto.org/docs/reference/formats/docx.html) for MS Word
    -   [Here](https://quarto.org/docs/reference/formats/html.html) for HTML documents

-   Markdown syntax

    -   [Markdown basics](https://quarto.org/docs/authoring/markdown-basics.html)

    -   [Markdown practice](https://www.markdowntutorial.com/)

-   Quarto (recommended to be reviewed after-class)

    -   [Get started](https://quarto.org/docs/get-started/)

# Basics of R

## Named objects

-   R is an **object-oriented language**, so we will be working on **named objects**.

-   We use the **left arrow** `<-` to create a named object, which assigns the **objects** on the RHS to the **name** on the LHS.[^4]

    -   The below code creates a new object called 'x' in the **environment**; x is a numeric object; its value is 2.

[^4]: You can also use equal sign `=`, but it's recommended to stick with R's tradition.

```{r}
x <- 3
x
```

-   After an object is created, we can refer to the object by its name, and operates on it.

```{r}
# Question: hmmm, why does Wei chooses these two numbers?
x^2
x^3
```

::: callout-note
### Exercise

Insert a code block in your quarto file, which does the following:

-   Create an object with name 'x' with value 2 + 2
:::

## Rules for naming object

For a variable to be valid, it should follow these rules

-   It should contain **letters**, **numbers**, and only **dot** or **underscore** characters.

-   It *cannot* start with a number (eg: 2iota).

```{r}
# 2iota <- 2
```

-   It *cannot* start with a dot followed by a number (eg: .2iota).

```{r}
# .iota <- 2
```

-   It should not start with an underscore (eg: \_iota).

```{r}
# _iota <- 2
```

-   It should not be a [reserved keyword](https://rdrr.io/r/base/Reserved.html).

```{r}
# mean <- 2
```

::: callout-tip
### Tips

It's good practice to use memorable names to name an object

-   For instance, use prefix "df\_" or "data\_" to name datasets.
:::

## Functions

-   In R, a **function** takes objects as input, run specific operations on the object(s) defined by the function, and then return an outcome object.

    -   The example below shows the R built-in function `mean`, which computes the average of several numbers.

```{r}
# generates a sequence 1,2,3
a <- 1:3 
```

```{r}
# print out a
a
```

```{r}
# take the mean of a using function mean()
mean(a)
```

-   We will heavily rely on functions to conduct data analyses. For how to use a new function, search the function in RStudio's `help` panel.

    -   **Description**: what the function does in a nutshell

    -   **Usage**: how to call the function

    -   **Arguments**: how you would like to run the function

    -   **Value**: what will be returned

    -   **Examples**: examples of how to use the function

::: callout-note
### Exercise

1.  Search and learn the usage of function "sum"
2.  Insert a code block in your quarto file to compute the sum of vector 1:3
:::

## Collection of functions: Packages

The base R already has many useful built-in functions to perform basic tasks, but as data scientists, we need more.

To perform certain tasks (such as a machine learning model), we can definitely write our own code from scratch, but it takes lots of (unnecessary) effort.

Fortunately, many **packages** have been written by others for us to directly use.

-   Install the package using the built-in function `install.packages()`. R will download the package to your computer. Installation of a package is only needed for the first time.

```{r}
install.packages('praise')
```

-   Load the packages using `library()`. Every time you restart the RStudio, packages need to be reloaded.

```{r}
library(praise)
```

-   Now that the package is loaded, you can use the functions in it. `praise()` is a function in the `praise` package.

```{r}
praise()
```

::: callout-tip
### Tips

After installation, just need to reload the packages using library() every time your restart RStudio.
:::

## Comment codes

You can put a `#` before any code, to indicate that any codes after the `#` on the same line are your comments, and will not be run by R.

It's a good practice to often comment your codes, so that you can help the future you to remember what you were trying to achieve.

```{r}
# print("Support Wei for an iPhone 15 Pro Max!")

# Below, x will be 1 rather than 1+1
x <- 1 # +1

```

# Data structures

Below are the complete list of objects in R.

![](images/r_data_structures.png){#fig-R-datastructure alt="Visualization of data structures"}

## Data types

To make the best of the R language, you'll need a strong understanding of the basic data types and data structures and how to operate on them. Data structures are very important to understand because these are the objects you will manipulate on a day-to-day basis in R.

-   Numeric (e.g.,2.5)
    -   We can use R as a calculator for numeric objects

```{r}
# Numeric Vector 
num2 <- 2.5
log(num2)
num2^2
exp(num2)
```

-   Logical (TRUE, FALSE)
    -   `TRUE` is equivalent to 1 in R; `FALSE` is equivalent to 0.

```{r}
log1 <- TRUE
log2 <- FALSE
```

-   Character (e.g. "Wei", "UCL", "1 + 1 = 3", "TRUE", etc.)
    -   within a pair of quotation marks; single or double quotation marks can both work.

```{r}
str1 <- "1 + 1 = 2"
```

-   Factor ("male", "female", etc.)
    -   this is an important R class for describing categories. We will discuss in more detail later in class when we learn linear regression.

```{r}
country <- c('UK','Spain','Italy','Multiverse')
factor(country)
```

## Check data types using class()

We can use `class()` to check the type of an object in R.

```{r}

a <- '1+1'
class(a)
```

```{r}
b <- 1+1
class(b)
```

This is very useful when we first load data from external databases, we need to make sure variables are of the correct data types.

## Data type: conversion

Sometimes, data types of variables from raw data may not be what we want; we need to change the data type of a variable to the appropriate one.

See the following example:

-   `a` is a string, and we cannot use mathematical operations on it, or R will report errors.

```{r}
#| error: true
a <- '1'
class(a)
a + 1
```

-   We can convert `a` to a numeric value. To convert from character to numeric, we use `as.numeric()`

```{r}
b <- as.numeric(a)
class(b)
```

# Vectors

## Creating vectors

### Creating vectors: c()

Vector can be created using the function `c()` by listing all the values in the parenthesis, separated by comma ','.

```{r}
x <- c(1, 3, 5, 10)
x
class(x)
```

Vectors must contain elements **of the same data type**. Otherwise, it will automatically convert elements into the same type (usually character type).

```{r}
x <- c(1, "intro", TRUE)
class(x)
```

### Checking the number of elements in a vector: length()

You can measure the length of a **vector** using the command `length()`

```{r}
x <- c('R',' is', ' fun')
length(x)
```

```{r}
y <- c()
length(y)
```

### Creating numeric sequences: seq() and rep()

It is also possible to easily create sequences with patterns

-   use `seq()` to create sequence with fixed steps

```{r}
# use seq()
seq(from = 1, to = 2, by = 0.1)
```

-   If step is 1, there's a simpler way using `:`

```{r}
1:5
```

-   use `rep()` to create repeated sequences.

```{r}
# replication using rep()
rep(c("A","B"), times = 5)
```

### Combine vectors

You can use `c()` to combine different vectors; this is very commonly used to concatenate vectors.

```{r vectors_multiple}
x <- 1:3 # from 1 to 3
y <- c(10, 15) # 10 and 15
z <- c(x,y) # x first and then y 
z
```

::: callout-note
### Exercise

Create a sequence of {1,1,2,2,3,3,3} using different methods.
:::

## Indexing and subsetting

We put the **index** of elements we would like to extract in a **square bracket `[ ]`**.[^5]

[^5]: Note that Python uses different ways to index and subset vectors and matrices.

-   Which element is in the second position?

```{r}
x <- c(1,3,8,7) 
x[2]
```

-   What are the first 2 elements?

```{r}
x[1:2] 
```

-   What are the 1st, 3rd and 4th elements?

```{r}
x[c(1,3,4)] 
```

## Element-wise operations

R is a **vectorized** language, meaning by default it will do vector operation internally.

-   If you operate on a vector with a single number, the operation will be applied to all elements in the vector

```{r}
x <- c(1,3,8,7)
x+2
x^2
```

::: callout-caution
### Caveats

When the length of vectors do not match, R will still do it for you without reporting error but a warning message. As you can see, even if the length of vectors does not match, R can still return an output but throws a warning message. It's important to check the warning messages when there is any!
:::

```{r}
x <- c(1,3,8,7)

y <- c(1,3,4) # careful!!! does not report error
x + y

```

::: callout-note
### Exercise

Create a geometric sequence {2,4,8,16,32} using seq().
:::

## Relational operations

-   We can compare a vector with a vector **of the same length**, which will do element-wise (element-by-element) comparison

```{r}
x <- c(1,3,8,7) 
y <- c(2,3,7,8)
x > y
x == y

```

-   We can also compare a vector with a scalar, because R is vectorized

```{r}
x <- c(1,3,8,7) 
x < 6 # is each element lower than 6?
x == 10 # is the element equal to 10?
```

-   Return the positions of elements that satisfy certain conditions: `which()`

```{r}
which(x == 8) # which element equals 8 

which.max(x) # which is the max element 

which.min(x)
```

::: callout-note
### Exercise

Find the minimum value of vector `x` using `which()`
:::

-   Sometimes, we may need to operation on multiple relational operations using `and` `or` `no`

    ```{r}
    T & F # and

    T | F # or

    !T # not
    ```

    -   For instance, we may want to find out elements that are smaller than 8 **and** larger than 3.

```{r}
  

which(x < 8 & x > 3 )
```

## Special relational operation: `%in%`

-   A special relational operation is `%in%` in R, which tests whether an element exists in the object.

```{r}

x <- c(1,3,8,7) 

3 %in% x

4 %in% x

```

## After-class exercise

-   Datacamp [Introduction to R](https://app.datacamp.com/learn/courses/free-introduction-to-r), finish the following:

    -   Intro to basics

    -   Vectors

# Matrices

## Matrices: creating matrices

### Creating matrices: matrix()

-   A matrix can be created using the command `matrix()`
    -   the first argument is the vector to be converted into matrix
    -   the second argument is the number of rows
    -   the last argument is the number of cols (optional)

```{r}
matrix(1:9, nrow = 3, ncol = 3)
```

::: callout-important
R by default inserts elements **vertically** by **columns**
:::

-   R will fill in the matrix by order and discard the remaining elements once fully filled

```{r}
matrix(1:9, nrow = 3, ncol = 2)
```

-   R will fill in the matrix by order and recycle to fill in the remaining elements

```{r}
matrix(1:9, nrow = 3, ncol = 4)
```

### Creating matrices: inserting by row

However, we can ask R to insert by rows by setting the `byrow` argument.

```{r matrix_byrow, include=T, echo=T}
matrix(1:9, nrow = 3, ncol = 3, byrow = TRUE)
```

### Creating matrices: concatenation of matrices cbind() and rbind()

We can use `cbind()` and `rbind()` to concatenate vectors and matrices into new matrices.

-   `cbind()` does the column binding

```{r, include=T, echo=T}
x <- cbind(1:3, 4:6) # column bind
x
```

-   `cbind()` can also operate on matrices.

```{r}
cbind(x,x)
```

-   `rbind()` does the row binding

```{r}
rbind(7:9, 10:12) # row bind
```

## Matrices: indexing and subsetting

Matrices have two dimensions: rows and columns. Therefore, to extract elements from a matrix, we just need to specify which row(s) and which column(s) we want.

```{r}
x
```

-   Extract an element
    -   1 is specified for row index, so we will extract elements from the first row
    -   1 is specified for column index, so we will extract elements from the the second column
    -   Altogether, we extract the single element in row 1, column 2.

```{r matrix_subset, include=T, echo=T}
x[1,2] # the element in the 1st row, 2nd column

```

-   If we leave blank for a dimension, we extract all elements of that dimension.
    -   1 is specified for row index, so we will extract elements from the first row
    -   Nothing is specified for column index, so we will extract all elements from all columns
    -   Altogether, we extract all elements in the first row

```{r}
x[1,] # all elements in the first row
```

::: callout-note
### Exercise

1.  Extract all elements in the second column

2.  Extract all elements in the first and third rows
:::

## Matrices: operations

Let's use 3 matrices `x`, `y`, and `z`:

```{r}
x <- matrix(1:6, nrow = 3)
y <- matrix(1:6, byrow = T, nrow = 2)
```

-   Functions will be vectorized over all elements in a matrix

```{r matrix_operations1, include=T, echo=T}
x
z<- x^2
z
```

### Matrices' operations: matrix addition and multiplication

-   If the two matrices are of the same dimensions, they can do element-wise operations, including the `*`

```{r matrix_operations2, include=T, echo=T}
x + z   # elementwise addition
x * z

```

-   We can also use `%*%` to indicate matrix multiplication

```{r}
x%*%y # matrix multiplication
```

### Matrices' operations: inverse and transpose

-   We use `t()` to do matrix transpose

```{r matrix_operations3, include=T, echo=T}
t(x) # transpose
```

-   We use `solve()` to get the inverse of an matrix

```{r}
solve(t(x)%*%x) # inverse; must be on a square matrix
```

# Data Frames

## Data Frames: creating dataframe

### Data Frames: create dataframe using data.frame()

-   Data Frame is the R object that we will deal with most of the time in the MSc program. You can think of `data.frame` as a spreadsheet in excel.

```{r dataframe, include=T, echo=T}
df <-  data.frame(id = 1:4,
  name = c("David", "Yongdong", "Anil", "Wei"),
  wage = rnorm(n=4, mean = 10^5, sd = 10^3), 
  male = c(T, T, T, T)
  )
df
```

-   Data frames can also be created from external sources, e.g., from a csv file or database.

## Data Frames: Basics

-   Each row stands for an `observation`; each column stands for a `variable`.

-   Each column should have a **unique** name.

-   Each column must contain the same data type, but the different columns can store different data types.

    -   compare with matrix?

-   Each column must be of same length, because rows have the same length across variables.

## Data Frames: check dimensions and variable types

-   You can verify the size of the `data.frame` using the command `dim()`; or `nrow()` and `ncol()`

```{r, include=T, echo=T}
dim(df)
nrow(df)
ncol(df)
```

-   You can get the data type info using the command `str()`

```{r, include=T, echo=T}
class(df)
str(df)
```

-   Get the variables names

```{r}
names(df)
```

## Data Frames: summary

-   Summarize the data frame

```{r dataframe_subset2, include=T, echo=T}
summary(df)
```

## Data Frames: subsetting

Since a dataframe is essentially a matrix, all the subsetting syntax with matrices can be applied here.

```{r dataframe_subset, include=T, echo=T}
df$name # subset a column
df[,c(2,3)] # can also subset like a matrix
```

We are interesting in the cylinders and the weights of inefficient cars (lower than 15 miles per gallon).

```{r dataframe_subset_mtcars, include=T, echo=T}
poll_cars <- mtcars[mtcars$mpg<15, c("cyl", "wt")] # remember to assign the generated dataframe to a new name
poll_cars
```

# Other data structures (Optional)

## Arrays

-   We can use `array()` to generate a high-dimensional array

-   Just like vectors and matrices, arrays can include only data types of the same kind.

-   A 3D array is basically a combination of matrices each laid on top of other

```{r arrays, include=T, echo=T}
x <- 1:4
x <- array(data = x, dim = c(2,3,2))
x
```

## Lists

A list is an R object that can contain anything. List is pretty useful when you need to store objects for latter use.

```{r list, include=T, echo=T}
x <- 1:2
y <- c("a", "b")
L <- list( numbers = x, letters = y)
```

## Lists: indexing and subsetting

There are many ways to extract a certain element from a list.

-   by index
-   by the name of the element
-   by dollar sign `$`

```{r list_subsetting, include=T, echo=T}
L[[1]] # extract the first element
L[['numbers']] # based on element name
L$numbers # extract the element called numbers
```

After extracting the element, we can work on the element further:

```{r list_subsetting2, include=T, echo=T}
L$numbers[1:3] > 2
```

# Programming Basics

## if/else

Sometimes, you want to run your code based on different conditions. For instance, if the observation is a missing value, then use the population average to impute the missing value. This is where `if/else` kicks in.

```         
if (condition == TRUE) {
  action 1
} else if (condition == TRUE ){
  action 2
} else {
  action 3
}
```

Example 1:

```{r controlflow, include=T, echo=T}

a <- 15

if (a > 10) {
larger_than_10 <- TRUE  
} else {
  larger_than_10 <- FALSE
}

larger_than_10  
```

Example 2:

```{r, include=T, echo=T}
x <- -5
if(x > 0){
  print("x is a non-negative number")
} else {
  print("x is a negative number")
}
```

## Loops

As the name suggests, in a loop the program repeats a set of instructions many times, until the stopping criteria is met.

Loop is very useful for repetitive jobs.

```{r loops, include=T, echo=T}
for (i in 1:10){ # i is the iterator
  # loop body: gets executed each time
  # the value of i changes with each iteration
}
```

## Nested loops

We can also nest loops into other loops.

```{r loops3, include=T, echo=T}
x <- cbind(1:3, 4:6) # column bind
x
y <- cbind(7:9, 10:12) # row bind
y

z <- x

for (i in 1:nrow(x)) {
  for (j in 1:ncol(x)){
    z[i,j] <- x[i,j] + y[i,j]
  }
}

z
```

## Functions

A function takes the argument as input, run some specified actions, and then return the result to us.

Functions are very useful. When we would like to test different ideas, we can combine functions with loops: We can write a function which takes different parameters as input, and we can use a loop to go through all the possible combinations of parameters.

### User-defined function syntax

Here is how to define a function in general:

```{r functions, include=T, echo=T}
function_name <- function(arg1 ,arg2 = default_value){
  # write the actions to be done with arg1 and arg2
  # you can have any number of arguments, with or without defaults
  return() # the last line is to return some value 
}
```

Example:

```{r functions2, include=T, echo=T}
magic <- function( x, y){
  return(x^2 + y)
}

magic(1,3)

```

## A comprehensive example

Task: write a function, which takes a vector as input, and returns the max value of the vector

```{r, include=T, echo=T}

get_max <- function(input){
  max_value <- input[1]
  for (i in 2:length(input) ) {
    if (input[i] > max_value) {
      max <- input[i]
    }
  }
  
  return(max)
}

get_max(c(-1,3,2))

```

::: callout-note
### Exercise

Write your own version of `which.max()` function
:::

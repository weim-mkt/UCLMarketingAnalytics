---
author: Dr Wei Miao
date: "`r (lubridate::ymd('20231004') + lubridate::dweeks(1))`"
date-format: long
institute: UCL School of Management
title: "Class 4 Data Wrangling with R Part I"
df-print: paged
colorlinks: true
code-line-numbers: true
format:
  html: 
    toc: true
    number-sections: true
    page-layout: full
    toc-depth: 2
    code-line-numbers: true
    code-copy: hover
  beamer: 
    toc: false
    toc-title: ""
    slide-level: 2
    section-titles: true
    theme: Frankfurt
    colortheme: beaver
    fonttheme: structurebold
    navigation: horizontal
    tbl-colwidths: auto
    fontsize: 9pt
knitr:
  opts_chunk:
    echo: true
    warning: true
    message: true
    error: true
execute: 
  freeze: auto
---

# Overview

## Class Objectives

-   Understand the major steps to conduct data analytics

-   **Data collection:** Learn how to collect first-hand data

-   **Data cleaning:** Learn how to use the `dplyr` package to collect, load, and clean data

-   **Data analysis:** Learn how to conduct descriptive analytics

# Data Analytics Workflow

## Overview

```{r, echo=FALSE,out.width="100%", fig.align='center'}
library(knitr)
include_graphics(path = "images/DataAnalyticsSteps.png")
```

## Collect Data

-   **Primary Data:** Data that are generated by the researcher himself/herself, surveys, interviews, experiments, specially designed for understanding and solving the research problem at hand.

-   **Secondary Data:** Existing data generated by the company's or consumer's past activities, as part of organizational record keeping.

```{r, echo=FALSE,out.width="50%", fig.align='center'}
  include_graphics(path = "images/class4_ComparisonOfData.png")
```

## Collect Data: Marketing Surveys

-   In a marketing survey, we typically would like to collect the following information from customers:

    -   purchase intention

    -   willingness to pay (WTP)

    -   shopping basket

    -   share of wallet (SoW)

    -   demographics

-   **Let's see a quick example of how to design a marketing survey!**

-   Useful supplementary readings if you need to design marketing surveys for your term 3 dissertation.

    -   [The quick start guide on how to conduct market research](https://www.surveymonkey.co.uk/mp/market-research-surveys/)

# Data Wrangling with R

## Data Frame Basics

-   Data Frame is the R object that we will deal with most of the time in the MSc program. You can think of `data.frame` as a spreadsheet in excel

-   Each row stands for an `observation`

-   Each column stands for a `variable`; each column should have a **unique** name.

-   Each column must contain the same data type, but the different columns can store different data types.[^1]

[^1]: Compared with matrix, is there any difference despite both being two-dimensional?

## Install and Load the `dplyr` package

-   In R, we will be using the `dplyr` package for data cleaning and manipulation.

```{r}
#| eval: false
install.packages("dplyr")
```

-   Load the package

```{r}
#| message: false
library(dplyr)
```

-   Load a csv format dataset called `data_demo` using `read.csv()`

```{r}
data_demo <- read.csv("https://www.dropbox.com/s/a0v38lpydls2emy/demographics.csv?dl=1")
```

-   To browse the whole dataset, we can simply click the dataset in the environment

## First Look at the Dataset

1.  What variables do the data have?

::: {.content-visible when-format="html"}
```{r}
names(data_demo)
```
:::

2.  What are the types of each variable?

::: {.content-visible when-format="html"}
```{r}
sapply(data_demo,
       class)
```
:::

-   Tip: We can use a function called `str()` short for structure.

::: {.content-hidden when-format="beamer"}
```{r}
str(data_demo)
```
:::

## Common Data Wrangling Operations

-   Select rows (`filter`)

-   Sort rows (`arrange`)

-   Select columns (`select`)

-   Generate new columns (`mutate`)

-   Group aggregation (`group_by`)

-   Merge datasets (`join`)

## Subset Rows Based on Conditions: `filter`

-   We can use `filter()` to select rows that meet certain logical criteria.
    -   The filter operation results in a new dataset, which is a subset of the original dataset after filtering
    -   The number of variables remains the same

![](images/filter.png){fig-align="center"}

-   **Important**: To store the generated new subset of data in RStudio, we need to assign it to a new object.

::: {.content-visible when-format="beamer"}
## Subset Rows Based on Conditions: `filter`

**Example**: From data_demo, find customers who are single

```{r}
# keep only single customers
data_demo_single <- filter(data_demo, Marital_Status == "Single" )

# show the first 5 records using head()
head(data_demo_single,5)
```
:::

::: {.content-hidden when-format="beamer"}
**Example**: From `data_demo`, find customers who are single

```{r}
# keep only single customers
data_demo_single <- filter(data_demo, Marital_Status == "Single" )

```
:::

## The Pipe Operator `%>%`

::: block
### Pipe Operator

`%>%` passes the **object in front** as the **first argument** of the **subsequent function**.
:::

![](images/pipeillustration.png){fig-align="center" width="150"}

## Example of the Pipe Operator `%>%`

```{r}
#| eval: false

# without using pipe
filter(data_demo, Marital_Status == 'Single')

# with pipe 
data_demo %>% filter(Marital_Status == 'Single')

```

## Why Do We Need Pipe Operator for Data Wrangling?

-   **Exercise**: find out **single** customers who have a **PhD** without using pipe.

::: {.content-visible when-format="beamer"}
```{r}
#| eval: false

# based on data_demo, find out customers who are single
data_demo_single <- 

# based on data_demo_single, 
# further find out single customers who have a PhD
data_demo_single_PhD <- 

```
:::

::: {.content-hidden when-format="beamer"}
```{r}
#| eval: false

# based on data_demo, find out customers who are single
data_demo_single <- filter(data_demo, Marital_Status == 'Single')

# based on data_demo_single, find out customers who are single and have PhD
data_demo_single_PhD <- filter(data_demo_single, Education == "PhD")

```
:::

::: {.content-visible when-format="beamer"}
## Why Do We Need Pipe Operator for Data Wrangling?
:::

-   **Exercise**: find out **single** customers who have a **PhD** using pipe.

```{r}
data_demo_single_PhD <- data_demo %>%
  filter(Marital_Status == 'Single') %>%
  filter(Education == 'PhD') %>%
  head() ## You can even continue with more filter steps
```

::: {.content-visible when-format="beamer"}
## Why Do We Need Pipe Operator for Data Wrangling?
:::

-   The pipe works like a conveyor belt in a factory, passing the intermediate outputs from the previous data wrangling step to the next step for further processing until you finish your data wrangling task.

![](images/pipe.png){fig-align="center" width="300"}

## Subset Rows Based on Multiple Conditions: `filter`

-   We can also add multiple criteria using `&`, `|`, and `!` to represent and, or, and not (induction week)

```{r}

data_demo %>%
  filter(Marital_Status == 'Single' & 
           Education == 'PhD') %>%
  head()

```

## Sort Rows: `arrange`

-   **`arrange()`** orders the rows by the values of selected columns.

    -   ascending order by default; for descending order, put a minus sign.

    -   allows multiple sorting variables separated by comma.

-   **Example**: sort customers based on marital status in ascending order and number of teens in descending order.

::: {.content-visible when-format="beamer"}
```{r}
#| eval: false
data_demo %>% 
  arrange(Marital_Status, -Teenhome) 
```
:::

::: {.content-hidden when-format="beamer"}
```{r}
data_demo %>% 
  arrange(Marital_Status, -Teenhome) %>%
  head(10)
```
:::

-   **Exercise:** sort customers based on income in descending order.

::: {.content-hidden when-format="beamer"}
```{r}
data_demo %>% 
  arrange(-Income) %>%
  head(10)
```
:::

## Generate New Variables: `mutate`

-   **`mutate()`** generates new variables in the dataset while preserving existing variables

-   **Example**: create a new variable named `Age` from `Year_Birth`.

::: {.content-visible when-format="beamer"}
```{r}
#| eval: false

data_demo %>%
  mutate(Age = 2023 - Year_Birth) 
```
:::

::: {.content-hidden when-format="beamer"}
```{r}
data_demo %>%
  mutate(Age = 2023 - Year_Birth) %>%
  head(10)
```
:::

-   **Exercise**: create a new variable named `totalkids`, which is the sum of `Kidhome` and `Teenhome`.

::: {.content-hidden when-format="beamer"}
```{r}
data_demo %>%
  mutate(totalkids = Kidhome + Teenhome) %>%
  head(10)
```
:::

## After-Class Exercise

-   Data camp dplyr exercise

-   Read "Preliminary Customer Analyses" dataset, and try to solve the case questions using the techniques learned today
